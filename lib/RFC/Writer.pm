use Object::Pad;

class RFC::Writer {
    use Carp 'croak';
    use File::Basename 'basename';
    use File::Spec::Functions qw(catfile catdir);
    use RFC::Config::Reader;
    use Template::Tiny::Strict;

    has $FILE    :param(file);
    has $VERBOSE :param(verbose) = 0;
    has $CONFIG;
    has @TOC;

    ADJUST {
        unless ( -e $FILE ) {
            croak("$FILE does not exist");
        }
        my $reader = RFC::Config::Reader->new( file => $FILE );
        $CONFIG = $reader->config;
        $self->_rewrite_config;
    }

    method generate_rfcs() {
        $self->_write_readme;
        $self->_write_rfcs;
        $self->_write_toc;
    }

    method _write_toc() {
        my $toc_file      = $CONFIG->{rfcs}[0]{file};      # toc is always first
        my $toc_list      = join "\n" => @TOC;
        my $FILE_contents = $self->_slurp($toc_file);
        my $marker        = $CONFIG->{main}{toc_marker};
        unless ( $FILE_contents =~ /\Q$marker\E/ ) {
            croak("TOC marker '$marker' not found in toc file: $toc_file");
        }
        $FILE_contents =~ s/\Q$marker\E/$toc_list/;
        $self->_splat( $toc_file, $FILE_contents );
    }

    method _write_readme() {
        my $readme_template = $CONFIG->{main}{readme_template};
        my $readme          = $CONFIG->{main}{readme};
        print "Processing $readme_template\n" if $VERBOSE;
        my $tts = Template::Tiny::Strict->new(
            forbid_undef  => 1,
            forbid_unused => 1,
            name          => 'README',
        );
        my $template = $self->_slurp($readme_template);
        $tts->process(
            \$template,
            {
                templates => $CONFIG->{rfcs},
                config    => $CONFIG->{main},
            },
            \my $out,
        );
        $self->_splat( $readme, $out );
    }

    method _write_rfcs {
        my $rfcs    = $CONFIG->{rfcs};
        my $default = { name => 'README', basename => '/README.md' };
        foreach my $i ( 0 .. $#$rfcs ) {
            my $prev = $i > 0 ? $rfcs->[ $i - 1 ] : $default;
            my $rfc  = $rfcs->[$i];
            my $next = $rfcs->[ $i + 1 ] || $default;

            my $FILE = $rfc->{file};
            print "Processing $rfc->{source}\n" if $VERBOSE;
            my $tts = Template::Tiny::Strict->new(
                forbid_undef  => 1,
                forbid_unused => 1,
            );
            my $template = $self->_get_rfc_template($rfc);
            $tts->process(
                \$template,
                {
                    prev   => $prev,
                    rfc    => $rfc,
                    next   => $next,
                    config => $CONFIG->{main},
                },
                \my $out
            );
            $self->_splat( $FILE, $out );
        }
    }

    method _rewrite_config() {
        my $rfcs            = $CONFIG->{rfcs};
        my $readme_template = $CONFIG->{main}{readme}
          or die "No readme found in [main] for config";
        my $toc_template = $CONFIG->{main}{toc}
          or die "No toc found in [main] for config";
        $self->_assert_template_name( $readme_template,
            $CONFIG->{main}{template_dir} );
        $CONFIG->{main}{readme_template} =
          catfile( $CONFIG->{main}{template_dir}, $readme_template );
        $CONFIG->{main}{toc_template} = catfile(
            $CONFIG->{main}{template_dir},
            $CONFIG->{main}{rfc_dir},
            $toc_template
        );

        my $index = 1;

        unshift @$rfcs => {
            key   => 'Table of Contents',
            value => $CONFIG->{main}{toc},
        };

        foreach my $rfc (@$rfcs) {
            my $FILEname = $rfc->{value};
            $self->_assert_template_name(
                $FILEname,
                $CONFIG->{main}{template_dir},
                $CONFIG->{main}{rfc_dir}
            );
            delete $rfc->{value};
            $rfc->{name}   = delete $rfc->{key};
            $rfc->{source} = catfile( $CONFIG->{main}{template_dir},
                $CONFIG->{main}{rfc_dir}, $FILEname );
            $rfc->{file}     = catfile( $CONFIG->{main}{rfc_dir}, $FILEname );
            $rfc->{basename} = $FILEname;
            $rfc->{index}    = $index;
            $index++;
        }
    }

    method _assert_template_name( $FILEname, @dirs ) {
        unless ( $FILEname =~ /\.md$/ ) {
            croak("Template filename must end in '.md': $FILEname");
        }
        my $location = catfile( @dirs, $FILEname );
        unless ( -e $location ) {
            croak("Template '$location' does not exist");
        }
    }

    method _get_rfc_template($rfc) {
        my $template = $self->_renumbered_headings($rfc);
        return <<"END";
Prev: [[% prev.name %]]([% prev.basename %])   
Next: [[% next.name %]]([% next.basename %])

---

# Section [% rfc.index %]: [% rfc.name %]

**This file is automatically generated. If you wish to submit a PR, do not
edit this file directly. Please edit
[[% rfc.source %]]([% config.github %]/tree/master/[% rfc.source %]) instead.**

---

$template

---

Prev: [[% prev.name %]]([% prev.basename %])   
Next: [[% next.name %]]([% next.basename %])
END
    }

    method _renumbered_headings($rfc) {
        my $template = $self->_slurp( $rfc->{source} );

        push @TOC =>
          "\n# [Section: $rfc->{index}: $rfc->{name}]($rfc->{basename})\n";

        # XXX fix me. Put this in config
        return $template if $rfc->{name} eq 'Changes';

        my $rewritten = '';
        my @lines     = split /\n/ => $template;

        my %levels = map { $_ => 0 } 1 .. 4;

        my $last_level = 1;

        my $in_code = 0;
      LINE: foreach my $line (@lines) {
            if ( $line =~ /^```/ ) {
                if ( !$in_code ) {
                    $in_code = 1;
                }
                else {
                    $in_code = 0;
                }
                $rewritten .= "$line\n";
            }
            elsif ( $line =~ /^(#+)\s+(.*)/ && !$in_code ) {
                my $hashes = $1;
                my $title  = $2;
                my $level  = length $hashes;
                if ( $last_level == $level ) {

                    # ## 1.2
                    # ## 1.3
                    $levels{$level}++;
                }
                elsif ( $last_level < $level ) {

                    # #
                    # ##
                    $levels{$level} = 1;
                }
                else {
                    # ##
                    # #
                    $levels{1}++;
                    for my $i ( 2 .. $level ) {
                        $levels{$i} = 1;
                    }
                }
                $last_level = $level;
                if ( $levels{1} == 0 ) {
                    croak("$rfc->{source} didn't start with a level 1 header");
                }
                my $section_num = join '.' => $rfc->{index},
                  map { $levels{$_} } 1 .. $level;
                my $num_dots = $section_num =~ tr/\././;
                my $leader   = $num_dots ? '..' x $num_dots : '';
                push @TOC => "* `$leader` $section_num $title";
                $rewritten .= "$hashes $section_num $title";
            }
            else {
                $rewritten .= "$line\n";
            }
        }
        return $rewritten;
    }

    method _slurp($FILE) {
        open my $fh, '<', $FILE or die "Cannot open $FILE for reading: $!";
        return do { local $/; <$fh> };
    }

    method _splat( $FILE, $data ) {
        if ( ref $data ) {
            croak("Data for splat '$FILE' must not be a reference ($data)");
        }
        open my $fh, '>', $FILE or die "Cannot open $FILE for writing: $!";
        print {$fh} $data;
    }
}
